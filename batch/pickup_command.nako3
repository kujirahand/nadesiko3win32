# -----------------------------------------------------
# プラグイン定義ファイルを読んで命令一覧(command.txt)を作成する
# -----------------------------------------------------
# --- 基本パスを取得 ---
母艦パス取得してパス抽出して基本パスに代入。
プラグイン一覧は[
    'src/plugin_system.js',
    'src/plugin_browser.js',
    'src/plugin_turtle.js',
    'src/plugin_node.js',
    'src/plugin_express.js'
 ]

関数定義とは変数
関数説明とは変数
助詞定義JSONとは変数
ヨミガナとは変数
カレントプラグインとは変数

プラグイン一覧を反復
    カレントプラグイン＝それ
 　　パスは「{基本パス}/{それ}」
 　　パスをプラグイン要約作成
ここまで
表示ログを「{基本パス}/batch/command.txt」に保存。

●プラグイン要約作成(Fを)
    Ｆからファイル名抽出して「.js」を空に置換してプラグイン名に代入。
    「{改行}■{プラグイン名}」を表示。
    Ｆを開く
    改行で区切る
    ここから反復
        毎行処理。
    ここまで
ここまで。

●定数定義処理(抽出文字列で)
　　定数定義＝トリム(抽出文字列[0])
　　抽出文字列[1]をトリム。
　　「const」を「定数」に置換
　　「var」を「変数」に置換して、Fタイプに代入。
　　定数値＝トリム（抽出文字列[2]）
　　ヨミガナ＝トリム（抽出文字列[3]）
　　もし、ヨミガナが空ならば
　　　　ヨミガナ＝定数定義。
　　ここまで。
　　「| {Fタイプ} | {定数定義} | | {定数値} | {ヨミガナ} |」を表示。
ここまで。

●毎行処理（Sを)
    S = トリム(S)
    # 見出し語？
    Ｓを『/^\/\/ @(.+)/』で正規表現マッチ
    もし、そうならば
        それの「^\/\/\s*@」を「」に正規表現置換して見出しに代入
        「●{見出}」を表示
        戻る
    ここまで。

    ＃定数でヨミガナ付き
    Ｓを『/'(.+?)'.+(const|var).+value:\s*(.+)\}.+?\/\/\s?@?(.*)/』で正規表現マッチ
    もし、そうならば
        抽出文字列で定数定義処理。戻る。
    ここまで。
    # 定数ヨミガナ抜け＞エラー
    Ｓを『/"(.+?)".+(const|var).+value:\s*(.+)\}/』で正規表現マッチ
    もし、そうならば
        定数定義＝抽出文字列[0]
        「--- ERROR --- 『｛定数定義｝』でヨミガナがありません。」と表示
        終わる。
    ここまで。
    ＃定数でオブジェクト定義があったりする場合
    Ｓを『/'(.+?)'\:.+?(const|var).+?\/\/(\s?)@?(.*)/』で正規表現マッチ
    もし、そうならば
        抽出文字列で定数定義処理。戻る。
    ここまで。

    # 関数定義？
    Ｓを『/'(.+?)'\s*:\s*\{\s*\/\/\s*\@(.+)$/』で正規表現マッチ
    もし、そうならば
        助詞定義JSON=[]
        ヨミガナ＝「」
        関数定義＝トリム(抽出文字列[0])
        関数説明＝トリム(抽出文字列[1])
        関数定義を表示
        関数説明で「//」が何文字目
        もし、それ＞０ならば
        　　関数説明を「//」で区切って、Aに代入。
        　　関数説明＝トリム(A[0])
        　　ヨミガナ＝トリム(A[1])
           ヨミガナ＝ヨミガナの「^@」を「」に正規表現置換
        　　もし、ヨミガナが空ならば、ヨミガナ＝関数定義。
        ここまで
        もし、ヨミガナが空ならば
        　　「--- ERROR ---『{関数定義}』でヨミガナがありません」と表示。
        　　終わる。
        ここまで。
        戻る。
    ここまで

    もし、関数定義≠空ならば
        # typeの行なら次の行を読むようにする
        Ｓを『/type\s*\:\s*'func'/』で正規表現マッチ
        もし、そうならば
        　　戻る
        ここまで。
        Ｓを『/uses\s*\:/』で正規表現マッチ
        もし、そうならば
        　　戻る
        ここまで。
        # 助詞の定義があるか?
        Ｓを『/josi\s*\:\s*(.+),$/』で正規表現マッチ
        もし、そうならば
            それ＝抽出文字列[0]
            トリム。
            #「[]」を「['']」に置換。
            「'」を「"」に置換。
            JSONデコード。
            助詞定義JSONに代入。
            戻る。
        ここまで
        # JS関数定義？ そうであれば、JSに対する引数名を得られる
        Sを『/^fn\s*\:\s*function\s*\((.*?)\)/』で正規表現マッチ。
        もし、そうならば
            助詞定義＝「」
            # システムオブジェクトへの参照は、なでしこ関数定義と関係ないので除去
            それ＝抽出文字列[0]
            「/(\,\s*sys|sys)$/」を「」に正規表現置換
            トリム。
            # JS引数の一覧を取得
            引数一覧=[]
            「,」で区切る
            反復
                大文字変換してトリムして、引数名に代入。
                もし、引数名＝空ならば、続ける。
                引数一覧に引数名を配列追加。
            ここまで。
            もし、要素数(引数一覧)≠要素数(助詞定義JSON)ならば
              「*** [警告] {カレントプラグイン}:『{関数定義}』で助詞の定義がJS関数の定義と異なります」と表示。
              引数一覧を表示。
              終わる。
            ここまで。
            AA=[]
            #「@@」&(引数一覧をJSONエンコード)を表示。
            Iを0から9まで繰り返す
                SS=「」
                NOを0から9まで繰り返す
                    もし、NO>=要素数(引数一覧)ならば、続ける。
                    もし、NO>=要素数(助詞定義JSON)ならば、続ける。
                    もし、I>=要素数(助詞定義JSON[NO])ならば、続ける。
                    ARG＝引数一覧[NO]
                    JOSI＝助詞定義JSON[NO][I]
                    SS = SS & ARG & JOSI
                ここまで;
                もし、SS≠空ならば、AAにSSを配列追加。
            ここまで
            助詞定義=AAを「/」で配列結合
            もし、助詞定義="undefined"ならば
              「*** [警告] {カレントプラグイン}:『{関数定義}』で助詞定義がundefinedです」と表示。
              助詞定義JSONをJSONエンコードして表示。
              AAを表示
              終わる。
            ここまで
            「| 関数 | {関数定義} | {助詞定義} | {関数説明} | {ヨミガナ}」を表示
            関数定義＝「」
        ここまで。
    ここまで
    関数定義＝「」
    定数定義＝「」
ここまで。
